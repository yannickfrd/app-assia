<?php

namespace App\Service\Api\GoogleApi;

use App\Entity\Support\Rdv;
use App\Service\Api\ApiCalendarServiceAbstract;
use Google\Exception;
use Google_Client;
use Google_Service_Calendar;
use Google_Service_Calendar_Event;

class GoogleCalendarApiService extends ApiCalendarServiceAbstract
{
    private const SESSION_ACCESS_TOKEN_GOOGLE = 'clientTokenGoogle';
    private const SESSION_REFRESH_TOKEN_GOOGLE = 'clientRefreshTokenGoogle';

    /**
     * Get the connexion url, generated by Google Api.
     * @return string
     * @throws Exception
     */
    public function getAuthUrl(): string
    {
        return $this->getClientDefault()->createAuthUrl();
    }

    /**
     * Authentication of the user and saving of the tokens in session.
     * @param string $authCode
     * @throws Exception
     */
    public function authClient(string $authCode): void
    {
        $client = $this->getClient($authCode);

        $this->session->set(self::SESSION_ACCESS_TOKEN_GOOGLE, $client->getAccessToken());
        $this->session->set(self::SESSION_REFRESH_TOKEN_GOOGLE, $client->getRefreshToken());
    }

    /**
     * Create new event on primary calendar.
     * @param bool $edit
     * @return string
     * @throws Exception
     */
    public function addRdv(bool $edit=false): string
    {
        $service = $this->createServiceCalendar();

        $calendarId = 'primary';
        $optionsParams = [];
        $event = $service->events->insert($calendarId, $this->createEvent(), $optionsParams);

        $this->setEventOnRdv('google', $event->getId());

        return $edit ? $this->getEditLink($event->htmlLink) : $event->htmlLink;
    }

    /**
     * Get "eId" from link.
     * @param string $showLink
     * @return string
     */
    private function getEditLink(string $showLink): string
    {
        $arrayShowLink = explode("/", $showLink);
        $lastShowLink = end($arrayShowLink);
        $arrayEid = explode("eid=", $lastShowLink);

        return "https://calendar.google.com/calendar/u/0/r/eventedit/" . end($arrayEid);
    }

    /**
     * Update an event on primary calendar.
     * @param int $rdvId
     * @return bool|string
     * @throws Exception
     */
    public function update(int $rdvId)
    {
        /** @var Rdv $rdv */
        $rdv = $this->em->getRepository(Rdv::class)->find($rdvId);

        if (null === $rdv->getGoogleEventId()) {
            $this->session->set('googleRdvId', $rdvId);
            return $this->addRdv();
        }

        $service = $this->createServiceCalendar();
        $getEvent = $service->events->get('primary', $rdv->getGoogleEventId());

        if (!$getEvent->count()) {
            return false;
        }

        // Hydration
        $event = $this->createEvent($rdv);
        $event->setId($getEvent->getId());

        $updateResponse = $service->events->update('primary', $getEvent->getId(), $event);

        return ($updateResponse->getStatus() === 'confirmed');
    }

    /**
     * Delete the event on primary calendar.
     * @param string $googleEventId
     * @throws Exception
     */
    public function deleteEvent(string $googleEventId): void
    {
        $service = $this->createServiceCalendar();
        $service->events->delete('primary', $googleEventId);
    }


    /**
     * Create a new Calendar Service.
     * @return Google_Service_Calendar
     * @throws Exception
     */
    private function createServiceCalendar(): Google_Service_Calendar
    {
        return new Google_Service_Calendar($this->getClient());
    }

    /**
     * Make a new Google Client by default.
     * @return Google_Client
     * @throws Exception
     */
    private function getClientDefault(): Google_Client
    {
        $client = new Google_Client();
        $client->setAuthConfig(__DIR__ . '\client_secret.json');
        $client->setApplicationName('app-assia');
//        $client->setPrompt('select_account');
        $client->addScope(Google_Service_Calendar::CALENDAR);
        $client->setRedirectUri('https://' . $_SERVER['HTTP_HOST'] . '/add-event-google-calendar');
        $client->setAccessType('offline');
        $client->setIncludeGrantedScopes(true);

        return $client;
    }

    /**
     * Init Google Client.
     * @param string|null $authCode
     * @return Google_Client
     * @throws Exception
     */
    private function getClient(string $authCode = null): Google_Client
    {
        $client = $this->getClientDefault();

        if (!$authCode && $this->session->has(self::SESSION_ACCESS_TOKEN_GOOGLE)) {
            $accessToken = $this->session->get(self::SESSION_ACCESS_TOKEN_GOOGLE);
            $client->setAccessToken($accessToken);

            if ($client->isAccessTokenExpired()) {
                $client->refreshToken($this->session->get(self::SESSION_REFRESH_TOKEN_GOOGLE));
                $this->session->set(self::SESSION_ACCESS_TOKEN_GOOGLE, $client->getAccessToken());
            }

            return $client;
        }

        $accessToken = $this->getToken($client, $authCode);
        $client->setAccessToken($accessToken);

        // Update token
        $this->session->set(self::SESSION_ACCESS_TOKEN_GOOGLE, $client->getAccessToken());
        // Save refresh_token. If the client have a "refresh_token", we save or change it on session
        if (null !== $client->getRefreshToken()) {
            $this->session->set(self::SESSION_REFRESH_TOKEN_GOOGLE, $client->getRefreshToken());
        }

        return $client;
    }

    /**
     * @param Google_Client $client
     * @param string|null $authCode
     * @return array
     */
    private function getToken(Google_Client $client, string $authCode=null): array
    {
        if ($authCode) {
            $accessToken = $client->fetchAccessTokenWithAuthCode($authCode);

            if (!array_key_exists('error', $accessToken)) {
                $this->session->set(self::SESSION_ACCESS_TOKEN_GOOGLE, $accessToken);
            }

            if ($client->isAccessTokenExpired()) {
                $client->refreshToken($this->session->get(self::SESSION_REFRESH_TOKEN_GOOGLE));
                $this->session->set(self::SESSION_ACCESS_TOKEN_GOOGLE, $client->getAccessToken());
            }

            return $accessToken;
        }

        if (
            $this->session->has(self::SESSION_ACCESS_TOKEN_GOOGLE) &&
            array_key_exists('error', $this->session->get(self::SESSION_ACCESS_TOKEN_GOOGLE))
        ) {
            $client->refreshToken($this->session->get(self::SESSION_REFRESH_TOKEN_GOOGLE));
            $this->session->set(self::SESSION_ACCESS_TOKEN_GOOGLE, $client->getAccessToken());

            return $client->getAccessToken();
        }

        return $this->session->get(self::SESSION_ACCESS_TOKEN_GOOGLE);
    }

    /**
     * Get the id of the rdv recorded in session or in parameter to hydrate a new event.
     * @param Rdv|null $rdv
     * @return Google_Service_Calendar_Event
     */
    private function createEvent(Rdv $rdv = null): Google_Service_Calendar_Event
    {
        if (!$rdv) {
            $rdv = $this->getRdv('google');
        }

        return new Google_Service_Calendar_Event([
            'summary' => $this->createTitleEvent($rdv),
            'location' => $rdv->getLocation(),
            'description' => $this->createBodyEvent(
                $rdv->getContent(),
                $rdv->getCreatedBy(),
                $rdv->getStatusToString()
            ),
            'start' => $this->createDateEvent($rdv->getStart()),
            'end' => $this->createDateEvent($rdv->getEnd()),
            'recurrence' => ['RRULE:FREQ=DAILY;COUNT=1'],
            'reminders' => [
                'useDefault' => TRUE,
                'overrides' => [
//                    array('method' => 'email', 'minutes' => 1),
//                    array('method' => 'popup', 'minutes' => 10),
                ],
            ],
        ]);
    }
}